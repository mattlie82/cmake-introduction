# 
# This is the top-level CMakeLists file.
# 
# Everything else is included from here.
#
# To start create an empty build directory within this directory (e.g. 'mkdir build').
# Then, change to that directory ('cd build') and run 'cmake ..' to let CMake go through this file.
# CMake will then generate a Makefile (in the build directory). 
# Finally, to compile and build the library, run 'make' in the build directory.

 
# First, set the minimum version of CMake that we need.

  cmake_minimum_required(VERSION 3.0)

# The  cmake_minimum_required()  function  is used  to  avoid  any cryptic error
# messages due to the CMakeLists.txt assuming a later version of CMake than  the
# one installed on the current host.

# Now, we set up the name of the project and specify which programming languages we intend to use.
# In this case, we want to use only C++ (CXX), but we also have to add C as language since the check 
# for LAPACK requires it.

  project(cmake_introduction CXX C)

# By specifying the programming language, we tell cmake to search for a C++ compiler.
# We can set a specific C++ compiler by calling CMake with 'cmake -DCMAKE_CXX_COMPILER=<PATH TO COMPILER> ..'.

# the build type is either Debug, Release, RelWithDebInfo or MinSizeRel.
# if no build type is given we set the debug as default build type.

  if(NOT CMAKE_BUILD_TYPE)
    set(CMAKE_BUILD_TYPE "Debug" CACHE STRING "Choose the type of build, options are: Debug Release RelWithDebInfo MinSizeRel."
       FORCE)
  endif()
  
# To better compare the build type string we canvert it into lower case.
  string(TOLOWER "${CMAKE_BUILD_TYPE}" _build_type_lower)

  if (_build_type_lower MATCHES "debug")
    message(STATUS "Debug build type")
    # Here we could set additional options only for the debug version, e.g. to treat warnings as errors.
    # It is important to do this in a platform-independent way! 
  elseif(_build_type_lower MATCHES "release")
    message(STATUS "Release build type")
    # Special options can be set here, e.g. loop unrolling, etc.
  else()
    message(STATUS "Some other build type")
  endif()

# CMake automatically sets the preprocessor flag NDEBUG for non-debug build types.

# We want to use the features provided by C++11. Older compilers need an explicit flag for this.
# Unfortunately, different compilers have different flags. Here we try them all, using an
# external macro called 'check_cxx_compiler_flags' that has to be explicitly included.
# You can define your own macros using the macro keyword.
# In newer versions of CMake (> 3.1), this can be achieved with the CMake command
# 'set_property(TARGET __name_of_target__ CXX_STANDARD 11)' or 
# 'set(CMAKE_CXX_STANDARD 11)' combined with 'set(CMAKE_CXX_STANDARD_REQUIRED ON)'
# for the entire project. See e.g. https://crascit.com/2015/03/28/enabling-cxx11-in-cmake/

  include(CheckCXXCompilerFlag)

# check three different flags.

  check_cxx_compiler_flag("-std=c++11"   COMPILER_SUPPORTS_CXX11)
  check_cxx_compiler_flag("-std=c++0x"   COMPILER_SUPPORTS_CXX0X)
  check_cxx_compiler_flag("-std=gnu++11" COMPILER_SUPPORTS_GNUPP11)

# if a check is successful the resepctive variable will be intialized. 
# We add the flag to the CMAKE_CXX_FLAGS

  if(COMPILER_SUPPORTS_CXX11)
    set(MY_CXX_FLAGS "${MY_CXX_FLAGS} -std=c++11")
  elseif(COMPILER_SUPPORTS_CXX0X)
    set(MY_CXX_FLAGS "${MY_CXX_FLAGS} -std=c++0x")
  elseif(COMPILER_SUPPORTS_GNUPP11)
    set(MY_CXX_FLAGS "${MY_CXX_FLAGS} -std=gnu++11")
  else()
    message(FATAL_ERROR "The compiler ${CMAKE_CXX_COMPILER} has no C++11 support. Please use a different C++ compiler.")
  endif()


# We define a new variable for the version number of this project

  set(CMAKE_INTRODUCTION_VERSION "1.0.2")

# We escape the quote signs to make them part of the string.
#
# By the way, the values stored in variables are accessed by using ${VARIABLE_NAME} in CMake.
# The version number will be included in the include/config.h header.

# We tell CMake to look for the lapack library.

  find_package(LAPACK)

# If LAPACK is found, cmake defines the variables LAPACK_FOUND, LAPACK_LIBRARIES, and others.
# CMake also has if-else constructs. We define a new varaible if LAPACK was found

  if (${LAPACK_FOUND})
    set(CMAKE_INTRODUCTION_WITH_LAPACK true)
  endif()

# We include the variable CMAKE_INTRODUCTION_VERSION in the include/config.h header file such that it 
# can be used in the source code, see src/main.cxx

# Next, we tell CMake to add the subdirectories 'include' and 'src' and 'documentation'. 
# The CMakeLists.txt files in the specified directories will be processed immediately 
# by CMake before processing in the current input file continues beyond this command. 

  add_subdirectory(include)
  add_subdirectory(src)
  add_subdirectory(documentation)


# We add a configure file, i.e. a file that will be generated by CMake based on a template
# defined by us. CMake will fill in the values that are specified in the template. The file
# will be written to the build directory.

  configure_file(
    "${CMAKE_CURRENT_SOURCE_DIR}/cmake/cmake_uninstall.cmake.in"
    "${CMAKE_CURRENT_BINARY_DIR}/cmake/cmake_uninstall.cmake"
    IMMEDIATE @ONLY)
  add_custom_target(uninstall
    "${CMAKE_COMMAND}" -P "${CMAKE_CURRENT_BINARY_DIR}/cmake/cmake_uninstall.cmake") 


# You can display a message to the user with the command 'message'

  message(STATUS "Configure of project '${CMAKE_PROJECT_NAME}' complete!")

# The first keyword is modifier, specifying what kind of message this is.
# Options are
# (none)         = Important information
# STATUS         = Incidental information
# WARNING        = CMake Warning, continue processing
# AUTHOR_WARNING = CMake Warning (dev), continue processing
# SEND_ERROR     = CMake Error, continue processing,
#                               but skip generation
# FATAL_ERROR    = CMake Error, stop processing and generation
# DEPRECATION    = CMake Deprecation Error or Warning if variable
#                  CMAKE_ERROR_DEPRECATED or CMAKE_WARN_DEPRECATED
#                  is enabled, respectively, else no message.

enable_testing()

add_subdirectory(tests)



find_program(PKGBUILD_FOUND pkgbuild)

if (PKGBUILD_FOUND)
  message(STATUS "pkgbuild found")
else()
    message(STATUS "pkgbuild NOT found")

endif()
